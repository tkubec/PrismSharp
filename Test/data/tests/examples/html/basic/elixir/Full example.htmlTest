# Example from http://learnxinyminutes.com/docs/elixir/

# Single line comments start with a number symbol.

# There's no multi-line comment,
# but you can stack multiple comments.

# To use the elixir shell use the `iex` command.
# Compile your modules with the `elixirc` command.

# Both should be in your path if you installed elixir correctly.

## ---------------------------
## -- Basic types
## ---------------------------

# There are numbers
3    # integer
0x1F # integer
3.0  # float

# Atoms, that are literals, a constant with name. They start with `:`.
:hello # atom

# Tuples that are stored contiguously in memory.
{1,2,3} # tuple

# We can access a tuple element with the `elem` function:
elem({1, 2, 3}, 0) #=> 1

# Lists that are implemented as linked lists.
[1,2,3] # list

# We can access the head and tail of a list as follows:
[head | tail] = [1,2,3]
head #=> 1
tail #=> [2,3]

# In elixir, just like in Erlang, the `=` denotes pattern matching and
# not an assignment.
#
# This means that the left-hand side (pattern) is matched against a
# right-hand side.
#
# This is how the above example of accessing the head and tail of a list works.

# A pattern match will error when the sides don't match, in this example
# the tuples have different sizes.
# {a, b, c} = {1, 2} #=> ** (MatchError) no match of right hand side value: {1,2}

# There are also binaries
<<1,2,3>> # binary

# Strings and char lists
"hello" # string
'hello' # char list

# Multi-line strings
"""
I'm a multi-line
string.
"""
#=> "I'm a multi-line\nstring.\n"

# Strings are all encoded in UTF-8:
"héllò" #=> "héllò"

# Strings are really just binaries, and char lists are just lists.
<<?a, ?b, ?c>> #=> "abc"
[?a, ?b, ?c]   #=> 'abc'

# `?a` in elixir returns the ASCII integer for the letter `a`
?a #=> 97

# To concatenate lists use `++`, for binaries use `<>`
[1,2,3] ++ [4,5]     #=> [1,2,3,4,5]
'hello ' ++ 'world'  #=> 'hello world'

<<1,2,3>> <> <<4,5>> #=> <<1,2,3,4,5>>
"hello " <> "world"  #=> "hello world"

# Ranges are represented as `start..end` (both inclusive)
1..10 #=> 1..10
lower..upper = 1..10 # Can use pattern matching on ranges as well
[lower, upper] #=> [1, 10]

## ---------------------------
## -- Operators
## ---------------------------

# Some math
1 + 1  #=> 2
10 - 5 #=> 5
5 * 2  #=> 10
10 / 2 #=> 5.0

# In elixir the operator `/` always returns a float.

# To do integer division use `div`
div(10, 2) #=> 5

# To get the division remainder use `rem`
rem(10, 3) #=> 1

# There are also boolean operators: `or`, `and` and `not`.
# These operators expect a boolean as their first argument.
true and true #=> true
false or true #=> true
# 1 and true    #=> ** (ArgumentError) argument error

# Elixir also provides `||`, `&&` and `!` which accept arguments of any type.
# All values except `false` and `nil` will evaluate to true.
1 || true  #=> 1
false && 1 #=> false
nil && 20  #=> nil
!true #=> false

# For comparisons we have: `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<` and `>`
1 == 1 #=> true
1 != 1 #=> false
1 < 2  #=> true

# `===` and `!==` are more strict when comparing integers and floats:
1 == 1.0  #=> true
1 === 1.0 #=> false

# We can also compare two different data types:
1 < :hello #=> true

# The overall sorting order is defined below:
# number < atom < reference < functions < port < pid < tuple < list < bit string

# To quote Joe Armstrong on this: "The actual order is not important,
# but that a total ordering is well defined is important."

## ---------------------------
## -- Control Flow
## ---------------------------

# `if` expression
if false do
  "This will never be seen"
else
  "This will"
end

# There's also `unless`
unless true do
  "This will never be seen"
else
  "This will"
end

# Remember pattern matching? Many control-flow structures in elixir rely on it.

# `case` allows us to compare a value against many patterns:
case {:one, :two} do
  {:four, :five} ->
    "This won't match"
  {:one, x} ->
    "This will match and bind `x` to `:two`"
  _ ->
    "This will match any value"
end

# It's common to bind the value to `_` if we don't need it.
# For example, if only the head of a list matters to us:
[head | _] = [1,2,3]
head #=> 1

# For better readability we can do the following:
[head | _tail] = [:a, :b, :c]
head #=> :a

# `cond` lets us check for many conditions at the same time.
# Use `cond` instead of nesting many `if` expressions.
cond do
  1 + 1 == 3 ->
    "I will never be seen"
  2 * 5 == 12 ->
    "Me neither"
  1 + 2 == 3 ->
    "But I will"
end

# It is common to set the last condition equal to `true`, which will always match.
cond do
  1 + 1 == 3 ->
    "I will never be seen"
  2 * 5 == 12 ->
    "Me neither"
  true ->
    "But I will (this is essentially an else)"
end

# `try/catch` is used to catch values that are thrown, it also supports an
# `after` clause that is invoked whether or not a value is caught.
try do
  throw(:hello)
catch
  message -> "Got #{message}."
after
  IO.puts("I'm the after clause.")
end
#=> I'm the after clause
# "Got :hello"

## ---------------------------
## -- Modules and Functions
## ---------------------------

# Anonymous functions (notice the dot)
square = fn(x) -> x * x end
square.(5) #=> 25

# They also accept many clauses and guards.
# Guards let you fine tune pattern matching,
# they are indicated by the `when` keyword:
f = fn
  x, y when x > 0 -> x + y
  x, y -> x * y
end

f.(1, 3)  #=> 4
f.(-1, 3) #=> -3

# Elixir also provides many built-in functions.
# These are available in the current scope.
is_number(10)    #=> true
is_list("hello") #=> false
elem({1,2,3}, 0) #=> 1

# You can group several functions into a module. Inside a module use `def`
# to define your functions.
defmodule Math do
  def sum(a, b) do
    a + b
  end

  def square(x) do
    x * x
  end
end

Math.sum(1, 2)  #=> 3
Math.square(3) #=> 9

# To compile our simple Math module save it as `math.ex` and use `elixirc`
# in your terminal: elixirc math.ex

# Inside a module we can define functions with `def` and private functions with `defp`.
# A function defined with `def` is available to be invoked from other modules,
# a private function can only be invoked locally.
defmodule PrivateMath do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end
end

PrivateMath.sum(1, 2)    #=> 3
# PrivateMath.do_sum(1, 2) #=> ** (UndefinedFunctionError)

# Function declarations also support guards and multiple clauses:
defmodule Geometry do
  def area({:rectangle, w, h}) do
    w * h
  end

  def area({:circle, r}) when is_number(r) do
    3.14 * r * r
  end
end

Geometry.area({:rectangle, 2, 3}) #=> 6
Geometry.area({:circle, 3})       #=> 28.25999999999999801048
# Geometry.area({:circle, "not_a_number"})
#=> ** (FunctionClauseError) no function clause matching in Geometry.area/1

# Due to immutability, recursion is a big part of elixir
defmodule Recursion do
  def sum_list([head | tail], acc) do
    sum_list(tail, acc + head)
  end

  def sum_list([], acc) do
    acc
  end
end

Recursion.sum_list([1,2,3], 0) #=> 6

# Elixir modules support attributes, there are built-in attributes and you
# may also add custom ones.
defmodule MyMod do
  @moduledoc """
  This is a built-in attribute on a example module.
  """

  @my_data 100 # This is a custom attribute.
  IO.inspect(@my_data) #=> 100
end

## ---------------------------
## -- Structs and Exceptions
## ---------------------------

# Structs are extensions on top of maps that bring default values,
# compile-time guarantees and polymorphism into Elixir.
defmodule Person do
  defstruct name: nil, age: 0, height: 0
end

joe_info = %Person{ name: "Joe", age: 30, height: 180 }
#=> %Person{age: 30, height: 180, name: "Joe"}

# Access the value of name
joe_info.name #=> "Joe"

# Update the value of age
older_joe_info = %{ joe_info | age: 31 }
#=> %Person{age: 31, height: 180, name: "Joe"}

# The `try` block with the `rescue` keyword is used to handle exceptions
try do
  raise "some error"
rescue
  RuntimeError -> "rescued a runtime error"
  _error -> "this will rescue any error"
end

# All exceptions have a message
try do
  raise "some error"
rescue
  x in [RuntimeError] ->
    x.message
end

## ---------------------------
## -- Concurrency
## ---------------------------

# Elixir relies on the actor model for concurrency. All we need to write
# concurrent programs in elixir are three primitives: spawning processes,
# sending messages and receiving messages.

# To start a new process we use the `spawn` function, which takes a function
# as argument.
f = fn -> 2 * 2 end #=> #Function<erl_eval.20.80484245>
spawn(f) #=> #PID<0.40.0>

# `spawn` returns a pid (process identifier), you can use this pid to send
# messages to the process. To do message passing we use the `send` operator.
# For all of this to be useful we need to be able to receive messages. This is
# achieved with the `receive` mechanism:
defmodule Geometry do
  def area_loop do
    receive do
      {:rectangle, w, h} ->
        IO.puts("Area = #{w * h}")
        area_loop()
      {:circle, r} ->
        IO.puts("Area = #{3.14 * r * r}")
        area_loop()
    end
  end
end

# Compile the module and create a process that evaluates `area_loop` in the shell
pid = spawn(fn -> Geometry.area_loop() end) #=> #PID<0.40.0>

# Send a message to `pid` that will match a pattern in the receive statement
send pid, {:rectangle, 2, 3}
#=> Area = 6
#   {:rectangle,2,3}

send pid, {:circle, 2}
#=> Area = 12.56000000000000049738
#   {:circle,2}

# The shell is also a process, you can use `self` to get the current pid
self() #=> #PID<0.27.0>
----------------------------------------------------
<span class="token comment"># Example from http://learnxinyminutes.com/docs/elixir/</span>

<span class="token comment"># Single line comments start with a number symbol.</span>

<span class="token comment"># There's no multi-line comment,</span>
<span class="token comment"># but you can stack multiple comments.</span>

<span class="token comment"># To use the elixir shell use the `iex` command.</span>
<span class="token comment"># Compile your modules with the `elixirc` command.</span>

<span class="token comment"># Both should be in your path if you installed elixir correctly.</span>

<span class="token comment">## ---------------------------</span>
<span class="token comment">## -- Basic types</span>
<span class="token comment">## ---------------------------</span>

<span class="token comment"># There are numbers</span>
<span class="token number">3</span>    <span class="token comment"># integer</span>
<span class="token number">0x1F</span> <span class="token comment"># integer</span>
<span class="token number">3.0</span>  <span class="token comment"># float</span>

<span class="token comment"># Atoms, that are literals, a constant with name. They start with `:`.</span>
<span class="token atom symbol">:hello</span> <span class="token comment"># atom</span>

<span class="token comment"># Tuples that are stored contiguously in memory.</span>
<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span> <span class="token comment"># tuple</span>

<span class="token comment"># We can access a tuple element with the `elem` function:</span>
<span class="token function">elem</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#=> 1</span>

<span class="token comment"># Lists that are implemented as linked lists.</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment"># list</span>

<span class="token comment"># We can access the head and tail of a list as follows:</span>
<span class="token punctuation">[</span>head <span class="token operator">|</span> tail<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
head <span class="token comment">#=> 1</span>
tail <span class="token comment">#=> [2,3]</span>

<span class="token comment"># In elixir, just like in Erlang, the `=` denotes pattern matching and</span>
<span class="token comment"># not an assignment.</span>
<span class="token comment">#</span>
<span class="token comment"># This means that the left-hand side (pattern) is matched against a</span>
<span class="token comment"># right-hand side.</span>
<span class="token comment">#</span>
<span class="token comment"># This is how the above example of accessing the head and tail of a list works.</span>

<span class="token comment"># A pattern match will error when the sides don't match, in this example</span>
<span class="token comment"># the tuples have different sizes.</span>
<span class="token comment"># {a, b, c} = {1, 2} #=> ** (MatchError) no match of right hand side value: {1,2}</span>

<span class="token comment"># There are also binaries</span>
<span class="token punctuation">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">>></span> <span class="token comment"># binary</span>

<span class="token comment"># Strings and char lists</span>
<span class="token string">"hello"</span> <span class="token comment"># string</span>
<span class="token string">'hello'</span> <span class="token comment"># char list</span>

<span class="token comment"># Multi-line strings</span>
<span class="token string">"""
I'm a multi-line
string.
"""</span>
<span class="token comment">#=> "I'm a multi-line\nstring.\n"</span>

<span class="token comment"># Strings are all encoded in UTF-8:</span>
<span class="token string">"héllò"</span> <span class="token comment">#=> "héllò"</span>

<span class="token comment"># Strings are really just binaries, and char lists are just lists.</span>
<span class="token punctuation">&lt;&lt;</span>?a<span class="token punctuation">,</span> ?b<span class="token punctuation">,</span> ?c<span class="token punctuation">>></span> <span class="token comment">#=> "abc"</span>
<span class="token punctuation">[</span>?a<span class="token punctuation">,</span> ?b<span class="token punctuation">,</span> ?c<span class="token punctuation">]</span>   <span class="token comment">#=> 'abc'</span>

<span class="token comment"># `?a` in elixir returns the ASCII integer for the letter `a`</span>
?a <span class="token comment">#=> 97</span>

<span class="token comment"># To concatenate lists use `++`, for binaries use `&lt;>`</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>     <span class="token comment">#=> [1,2,3,4,5]</span>
<span class="token string">'hello '</span> <span class="token operator">++</span> <span class="token string">'world'</span>  <span class="token comment">#=> 'hello world'</span>

<span class="token punctuation">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">>></span> <span class="token operator">&lt;></span> <span class="token punctuation">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">>></span> <span class="token comment">#=> &lt;&lt;1,2,3,4,5>></span>
<span class="token string">"hello "</span> <span class="token operator">&lt;></span> <span class="token string">"world"</span>  <span class="token comment">#=> "hello world"</span>

<span class="token comment"># Ranges are represented as `start..end` (both inclusive)</span>
<span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span> <span class="token comment">#=> 1..10</span>
lower<span class="token operator">..</span>upper <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span> <span class="token comment"># Can use pattern matching on ranges as well</span>
<span class="token punctuation">[</span>lower<span class="token punctuation">,</span> upper<span class="token punctuation">]</span> <span class="token comment">#=> [1, 10]</span>

<span class="token comment">## ---------------------------</span>
<span class="token comment">## -- Operators</span>
<span class="token comment">## ---------------------------</span>

<span class="token comment"># Some math</span>
<span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment">#=> 2</span>
<span class="token number">10</span> <span class="token operator">-</span> <span class="token number">5</span> <span class="token comment">#=> 5</span>
<span class="token number">5</span> <span class="token operator">*</span> <span class="token number">2</span>  <span class="token comment">#=> 10</span>
<span class="token number">10</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token comment">#=> 5.0</span>

<span class="token comment"># In elixir the operator `/` always returns a float.</span>

<span class="token comment"># To do integer division use `div`</span>
<span class="token function">div</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">#=> 5</span>

<span class="token comment"># To get the division remainder use `rem`</span>
<span class="token function">rem</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">#=> 1</span>

<span class="token comment"># There are also boolean operators: `or`, `and` and `not`.</span>
<span class="token comment"># These operators expect a boolean as their first argument.</span>
<span class="token boolean">true</span> <span class="token keyword">and</span> <span class="token boolean">true</span> <span class="token comment">#=> true</span>
<span class="token boolean">false</span> <span class="token keyword">or</span> <span class="token boolean">true</span> <span class="token comment">#=> true</span>
<span class="token comment"># 1 and true    #=> ** (ArgumentError) argument error</span>

<span class="token comment"># Elixir also provides `||`, `&amp;&amp;` and `!` which accept arguments of any type.</span>
<span class="token comment"># All values except `false` and `nil` will evaluate to true.</span>
<span class="token number">1</span> <span class="token operator">||</span> <span class="token boolean">true</span>  <span class="token comment">#=> 1</span>
<span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token number">1</span> <span class="token comment">#=> false</span>
<span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token number">20</span>  <span class="token comment">#=> nil</span>
<span class="token operator">!</span><span class="token boolean">true</span> <span class="token comment">#=> false</span>

<span class="token comment"># For comparisons we have: `==`, `!=`, `===`, `!==`, `&lt;=`, `>=`, `&lt;` and `>`</span>
<span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token comment">#=> true</span>
<span class="token number">1</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token comment">#=> false</span>
<span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">2</span>  <span class="token comment">#=> true</span>

<span class="token comment"># `===` and `!==` are more strict when comparing integers and floats:</span>
<span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1.0</span>  <span class="token comment">#=> true</span>
<span class="token number">1</span> <span class="token operator">===</span> <span class="token number">1.0</span> <span class="token comment">#=> false</span>

<span class="token comment"># We can also compare two different data types:</span>
<span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token atom symbol">:hello</span> <span class="token comment">#=> true</span>

<span class="token comment"># The overall sorting order is defined below:</span>
<span class="token comment"># number &lt; atom &lt; reference &lt; functions &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</span>

<span class="token comment"># To quote Joe Armstrong on this: "The actual order is not important,</span>
<span class="token comment"># but that a total ordering is well defined is important."</span>

<span class="token comment">## ---------------------------</span>
<span class="token comment">## -- Control Flow</span>
<span class="token comment">## ---------------------------</span>

<span class="token comment"># `if` expression</span>
<span class="token keyword">if</span> <span class="token boolean">false</span> <span class="token keyword">do</span>
  <span class="token string">"This will never be seen"</span>
<span class="token keyword">else</span>
  <span class="token string">"This will"</span>
<span class="token keyword">end</span>

<span class="token comment"># There's also `unless`</span>
<span class="token keyword">unless</span> <span class="token boolean">true</span> <span class="token keyword">do</span>
  <span class="token string">"This will never be seen"</span>
<span class="token keyword">else</span>
  <span class="token string">"This will"</span>
<span class="token keyword">end</span>

<span class="token comment"># Remember pattern matching? Many control-flow structures in elixir rely on it.</span>

<span class="token comment"># `case` allows us to compare a value against many patterns:</span>
<span class="token keyword">case</span> <span class="token punctuation">{</span><span class="token atom symbol">:one</span><span class="token punctuation">,</span> <span class="token atom symbol">:two</span><span class="token punctuation">}</span> <span class="token keyword">do</span>
  <span class="token punctuation">{</span><span class="token atom symbol">:four</span><span class="token punctuation">,</span> <span class="token atom symbol">:five</span><span class="token punctuation">}</span> <span class="token operator">-></span>
    <span class="token string">"This won't match"</span>
  <span class="token punctuation">{</span><span class="token atom symbol">:one</span><span class="token punctuation">,</span> x<span class="token punctuation">}</span> <span class="token operator">-></span>
    <span class="token string">"This will match and bind `x` to `:two`"</span>
  _ <span class="token operator">-></span>
    <span class="token string">"This will match any value"</span>
<span class="token keyword">end</span>

<span class="token comment"># It's common to bind the value to `_` if we don't need it.</span>
<span class="token comment"># For example, if only the head of a list matters to us:</span>
<span class="token punctuation">[</span>head <span class="token operator">|</span> _<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
head <span class="token comment">#=> 1</span>

<span class="token comment"># For better readability we can do the following:</span>
<span class="token punctuation">[</span>head <span class="token operator">|</span> _tail<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token atom symbol">:a</span><span class="token punctuation">,</span> <span class="token atom symbol">:b</span><span class="token punctuation">,</span> <span class="token atom symbol">:c</span><span class="token punctuation">]</span>
head <span class="token comment">#=> :a</span>

<span class="token comment"># `cond` lets us check for many conditions at the same time.</span>
<span class="token comment"># Use `cond` instead of nesting many `if` expressions.</span>
<span class="token keyword">cond</span> <span class="token keyword">do</span>
  <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">-></span>
    <span class="token string">"I will never be seen"</span>
  <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">12</span> <span class="token operator">-></span>
    <span class="token string">"Me neither"</span>
  <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">-></span>
    <span class="token string">"But I will"</span>
<span class="token keyword">end</span>

<span class="token comment"># It is common to set the last condition equal to `true`, which will always match.</span>
<span class="token keyword">cond</span> <span class="token keyword">do</span>
  <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">-></span>
    <span class="token string">"I will never be seen"</span>
  <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">12</span> <span class="token operator">-></span>
    <span class="token string">"Me neither"</span>
  <span class="token boolean">true</span> <span class="token operator">-></span>
    <span class="token string">"But I will (this is essentially an else)"</span>
<span class="token keyword">end</span>

<span class="token comment"># `try/catch` is used to catch values that are thrown, it also supports an</span>
<span class="token comment"># `after` clause that is invoked whether or not a value is caught.</span>
<span class="token keyword">try</span> <span class="token keyword">do</span>
  <span class="token function">throw</span><span class="token punctuation">(</span><span class="token atom symbol">:hello</span><span class="token punctuation">)</span>
<span class="token keyword">catch</span>
  message <span class="token operator">-></span> <span class="token string">"Got <span class="token interpolation"><span class="token delimiter punctuation">#{</span>message<span class="token delimiter punctuation">}</span></span>."</span>
<span class="token keyword">after</span>
  <span class="token module class-name">IO</span><span class="token punctuation">.</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"I'm the after clause."</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token comment">#=> I'm the after clause</span>
<span class="token comment"># "Got :hello"</span>

<span class="token comment">## ---------------------------</span>
<span class="token comment">## -- Modules and Functions</span>
<span class="token comment">## ---------------------------</span>

<span class="token comment"># Anonymous functions (notice the dot)</span>
square <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-></span> x <span class="token operator">*</span> x <span class="token keyword">end</span>
<span class="token function">square</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">#=> 25</span>

<span class="token comment"># They also accept many clauses and guards.</span>
<span class="token comment"># Guards let you fine tune pattern matching,</span>
<span class="token comment"># they are indicated by the `when` keyword:</span>
f <span class="token operator">=</span> <span class="token keyword">fn</span>
  x<span class="token punctuation">,</span> y <span class="token keyword">when</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">-></span> x <span class="token operator">+</span> y
  x<span class="token punctuation">,</span> y <span class="token operator">-></span> x <span class="token operator">*</span> y
<span class="token keyword">end</span>

<span class="token function">f</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment">#=> 4</span>
<span class="token function">f</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">#=> -3</span>

<span class="token comment"># Elixir also provides many built-in functions.</span>
<span class="token comment"># These are available in the current scope.</span>
<span class="token function">is_number</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token comment">#=> true</span>
<span class="token function">is_list</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span> <span class="token comment">#=> false</span>
<span class="token function">elem</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#=> 1</span>

<span class="token comment"># You can group several functions into a module. Inside a module use `def`</span>
<span class="token comment"># to define your functions.</span>
<span class="token keyword">defmodule</span> <span class="token module class-name">Math</span> <span class="token keyword">do</span>
  <span class="token keyword">def</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">do</span>
    a <span class="token operator">+</span> b
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">do</span>
    x <span class="token operator">*</span> x
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token module class-name">Math</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">#=> 3</span>
<span class="token module class-name">Math</span><span class="token punctuation">.</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">#=> 9</span>

<span class="token comment"># To compile our simple Math module save it as `math.ex` and use `elixirc`</span>
<span class="token comment"># in your terminal: elixirc math.ex</span>

<span class="token comment"># Inside a module we can define functions with `def` and private functions with `defp`.</span>
<span class="token comment"># A function defined with `def` is available to be invoked from other modules,</span>
<span class="token comment"># a private function can only be invoked locally.</span>
<span class="token keyword">defmodule</span> <span class="token module class-name">PrivateMath</span> <span class="token keyword">do</span>
  <span class="token keyword">def</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">do_sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> <span class="token function">do_sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token keyword">do</span>
    a <span class="token operator">+</span> b
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token module class-name">PrivateMath</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment">#=> 3</span>
<span class="token comment"># PrivateMath.do_sum(1, 2) #=> ** (UndefinedFunctionError)</span>

<span class="token comment"># Function declarations also support guards and multiple clauses:</span>
<span class="token keyword">defmodule</span> <span class="token module class-name">Geometry</span> <span class="token keyword">do</span>
  <span class="token keyword">def</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:rectangle</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    w <span class="token operator">*</span> h
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:circle</span><span class="token punctuation">,</span> r<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">when</span> <span class="token function">is_number</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token number">3.14</span> <span class="token operator">*</span> r <span class="token operator">*</span> r
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token module class-name">Geometry</span><span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:rectangle</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">#=> 6</span>
<span class="token module class-name">Geometry</span><span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token atom symbol">:circle</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token comment">#=> 28.25999999999999801048</span>
<span class="token comment"># Geometry.area({:circle, "not_a_number"})</span>
<span class="token comment">#=> ** (FunctionClauseError) no function clause matching in Geometry.area/1</span>

<span class="token comment"># Due to immutability, recursion is a big part of elixir</span>
<span class="token keyword">defmodule</span> <span class="token module class-name">Recursion</span> <span class="token keyword">do</span>
  <span class="token keyword">def</span> <span class="token function">sum_list</span><span class="token punctuation">(</span><span class="token punctuation">[</span>head <span class="token operator">|</span> tail<span class="token punctuation">]</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">sum_list</span><span class="token punctuation">(</span>tail<span class="token punctuation">,</span> acc <span class="token operator">+</span> head<span class="token punctuation">)</span>
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> <span class="token function">sum_list</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span> <span class="token keyword">do</span>
    acc
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token module class-name">Recursion</span><span class="token punctuation">.</span><span class="token function">sum_list</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">#=> 6</span>

<span class="token comment"># Elixir modules support attributes, there are built-in attributes and you</span>
<span class="token comment"># may also add custom ones.</span>
<span class="token keyword">defmodule</span> <span class="token module class-name">MyMod</span> <span class="token keyword">do</span>
  <span class="token doc"><span class="token attribute">@moduledoc</span> <span class="token string">"""
  This is a built-in attribute on a example module.
  """</span></span>

  <span class="token attribute variable">@my_data</span> <span class="token number">100</span> <span class="token comment"># This is a custom attribute.</span>
  <span class="token module class-name">IO</span><span class="token punctuation">.</span><span class="token function">inspect</span><span class="token punctuation">(</span><span class="token attribute variable">@my_data</span><span class="token punctuation">)</span> <span class="token comment">#=> 100</span>
<span class="token keyword">end</span>

<span class="token comment">## ---------------------------</span>
<span class="token comment">## -- Structs and Exceptions</span>
<span class="token comment">## ---------------------------</span>

<span class="token comment"># Structs are extensions on top of maps that bring default values,</span>
<span class="token comment"># compile-time guarantees and polymorphism into Elixir.</span>
<span class="token keyword">defmodule</span> <span class="token module class-name">Person</span> <span class="token keyword">do</span>
  <span class="token keyword">defstruct</span> <span class="token attr-name">name:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token attr-name">age:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token attr-name">height:</span> <span class="token number">0</span>
<span class="token keyword">end</span>

joe_info <span class="token operator">=</span> <span class="token punctuation">%</span><span class="token module class-name">Person</span><span class="token punctuation">{</span> <span class="token attr-name">name:</span> <span class="token string">"Joe"</span><span class="token punctuation">,</span> <span class="token attr-name">age:</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token attr-name">height:</span> <span class="token number">180</span> <span class="token punctuation">}</span>
<span class="token comment">#=> %Person{age: 30, height: 180, name: "Joe"}</span>

<span class="token comment"># Access the value of name</span>
joe_info<span class="token punctuation">.</span>name <span class="token comment">#=> "Joe"</span>

<span class="token comment"># Update the value of age</span>
older_joe_info <span class="token operator">=</span> <span class="token punctuation">%</span><span class="token punctuation">{</span> joe_info <span class="token operator">|</span> <span class="token attr-name">age:</span> <span class="token number">31</span> <span class="token punctuation">}</span>
<span class="token comment">#=> %Person{age: 31, height: 180, name: "Joe"}</span>

<span class="token comment"># The `try` block with the `rescue` keyword is used to handle exceptions</span>
<span class="token keyword">try</span> <span class="token keyword">do</span>
  <span class="token keyword">raise</span> <span class="token string">"some error"</span>
<span class="token keyword">rescue</span>
  <span class="token module class-name">RuntimeError</span> <span class="token operator">-></span> <span class="token string">"rescued a runtime error"</span>
  _error <span class="token operator">-></span> <span class="token string">"this will rescue any error"</span>
<span class="token keyword">end</span>

<span class="token comment"># All exceptions have a message</span>
<span class="token keyword">try</span> <span class="token keyword">do</span>
  <span class="token keyword">raise</span> <span class="token string">"some error"</span>
<span class="token keyword">rescue</span>
  x <span class="token operator">in</span> <span class="token punctuation">[</span><span class="token module class-name">RuntimeError</span><span class="token punctuation">]</span> <span class="token operator">-></span>
    x<span class="token punctuation">.</span>message
<span class="token keyword">end</span>

<span class="token comment">## ---------------------------</span>
<span class="token comment">## -- Concurrency</span>
<span class="token comment">## ---------------------------</span>

<span class="token comment"># Elixir relies on the actor model for concurrency. All we need to write</span>
<span class="token comment"># concurrent programs in elixir are three primitives: spawning processes,</span>
<span class="token comment"># sending messages and receiving messages.</span>

<span class="token comment"># To start a new process we use the `spawn` function, which takes a function</span>
<span class="token comment"># as argument.</span>
f <span class="token operator">=</span> <span class="token keyword">fn</span> <span class="token operator">-></span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token keyword">end</span> <span class="token comment">#=> #Function&lt;erl_eval.20.80484245></span>
<span class="token function">spawn</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token comment">#=> #PID&lt;0.40.0></span>

<span class="token comment"># `spawn` returns a pid (process identifier), you can use this pid to send</span>
<span class="token comment"># messages to the process. To do message passing we use the `send` operator.</span>
<span class="token comment"># For all of this to be useful we need to be able to receive messages. This is</span>
<span class="token comment"># achieved with the `receive` mechanism:</span>
<span class="token keyword">defmodule</span> <span class="token module class-name">Geometry</span> <span class="token keyword">do</span>
  <span class="token keyword">def</span> area_loop <span class="token keyword">do</span>
    receive <span class="token keyword">do</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:rectangle</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">}</span> <span class="token operator">-></span>
        <span class="token module class-name">IO</span><span class="token punctuation">.</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Area = <span class="token interpolation"><span class="token delimiter punctuation">#{</span>w <span class="token operator">*</span> h<span class="token delimiter punctuation">}</span></span>"</span><span class="token punctuation">)</span>
        <span class="token function">area_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span><span class="token atom symbol">:circle</span><span class="token punctuation">,</span> r<span class="token punctuation">}</span> <span class="token operator">-></span>
        <span class="token module class-name">IO</span><span class="token punctuation">.</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Area = <span class="token interpolation"><span class="token delimiter punctuation">#{</span><span class="token number">3.14</span> <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token delimiter punctuation">}</span></span>"</span><span class="token punctuation">)</span>
        <span class="token function">area_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token comment"># Compile the module and create a process that evaluates `area_loop` in the shell</span>
pid <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token operator">-></span> <span class="token module class-name">Geometry</span><span class="token punctuation">.</span><span class="token function">area_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token comment">#=> #PID&lt;0.40.0></span>

<span class="token comment"># Send a message to `pid` that will match a pattern in the receive statement</span>
send pid<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token atom symbol">:rectangle</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
<span class="token comment">#=> Area = 6</span>
<span class="token comment">#   {:rectangle,2,3}</span>

send pid<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token atom symbol">:circle</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>
<span class="token comment">#=> Area = 12.56000000000000049738</span>
<span class="token comment">#   {:circle,2}</span>

<span class="token comment"># The shell is also a process, you can use `self` to get the current pid</span>
<span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#=> #PID&lt;0.27.0></span>

----------------------------------------------------