; This code is copied from https://learnxinyminutes.com/docs/clojure/

; Comments start with semicolons.

; Clojure is written in "forms", which are just
; lists of things inside parentheses, separated by whitespace.
;
; The clojure reader assumes that the first thing is a
; function or macro to call, and the rest are arguments.

; The first call in a file should be ns, to set the namespace
(ns learnclojure)

; More basic examples:

; str will create a string out of all its arguments
(str "Hello" " " "World") ; => "Hello World"

; Math is straightforward
(+ 1 1) ; => 2
(- 2 1) ; => 1
(* 1 2) ; => 2
(/ 2 1) ; => 2

; Equality is =
(= 1 1) ; => true
(= 2 1) ; => false

; You need not for logic, too
(not true) ; => false

; Nesting forms works as you expect
(+ 1 (- 3 2)) ; = 1 + (3 - 2) => 2

; Types
;;;;;;;;;;;;;

; Clojure uses Java's object types for booleans, strings and numbers.
; Use `class` to inspect them.
(class 1) ; Integer literals are java.lang.Long by default
(class 1.); Float literals are java.lang.Double
(class ""); Strings always double-quoted, and are java.lang.String
(class false) ; Booleans are java.lang.Boolean
(class nil); The "null" value is called nil

; If you want to create a literal list of data, use ' to stop it from
; being evaluated
'(+ 1 2) ; => (+ 1 2)
; (shorthand for (quote (+ 1 2)))

; You can eval a quoted list
(eval '(+ 1 2)) ; => 3

; Collections & Sequences
;;;;;;;;;;;;;;;;;;;

; Lists are linked-list data structures, while Vectors are array-backed.
; Vectors and Lists are java classes too!
(class [1 2 3]); => clojure.lang.PersistentVector
(class '(1 2 3)); => clojure.lang.PersistentList

; A list would be written as just (1 2 3), but we have to quote
; it to stop the reader thinking it's a function.
; Also, (list 1 2 3) is the same as '(1 2 3)

; "Collections" are just groups of data
; Both lists and vectors are collections:
(coll? '(1 2 3)) ; => true
(coll? [1 2 3]) ; => true

; "Sequences" (seqs) are abstract descriptions of lists of data.
; Only lists are seqs.
(seq? '(1 2 3)) ; => true
(seq? [1 2 3]) ; => false

; A seq need only provide an entry when it is accessed.
; So, seqs which can be lazy -- they can define infinite series:
(range 4) ; => (0 1 2 3)
(range) ; => (0 1 2 3 4 ...) (an infinite series)
(take 4 (range)) ;  (0 1 2 3)

; Use cons to add an item to the beginning of a list or vector
(cons 4 [1 2 3]) ; => (4 1 2 3)
(cons 4 '(1 2 3)) ; => (4 1 2 3)

; Conj will add an item to a collection in the most efficient way.
; For lists, they insert at the beginning. For vectors, they insert at the end.
(conj [1 2 3] 4) ; => [1 2 3 4]
(conj '(1 2 3) 4) ; => (4 1 2 3)

; Use concat to add lists or vectors together
(concat [1 2] '(3 4)) ; => (1 2 3 4)

; Use filter, map to interact with collections
(map inc [1 2 3]) ; => (2 3 4)
(filter even? [1 2 3]) ; => (2)

; Use reduce to reduce them
(reduce + [1 2 3 4])
; = (+ (+ (+ 1 2) 3) 4)
; => 10

; Reduce can take an initial-value argument too
(reduce conj [] '(3 2 1))
; = (conj (conj (conj [] 3) 2) 1)
; => [3 2 1]

; Functions
;;;;;;;;;;;;;;;;;;;;;

; Use fn to create new functions. A function always returns
; its last statement.
(fn [] "Hello World") ; => fn

; (You need extra parens to call it)
((fn [] "Hello World")) ; => "Hello World"

; You can create a var using def
(def x 1)
x ; => 1

; Assign a function to a var
(def hello-world (fn [] "Hello World"))
(hello-world) ; => "Hello World"

; You can shorten this process by using defn
(defn hello-world [] "Hello World")

; The [] is the list of arguments for the function.
(defn hello [name]
  (str "Hello " name))
(hello "Steve") ; => "Hello Steve"

; You can also use this shorthand to create functions:
(def hello2 #(str "Hello " %1))
(hello2 "Fanny") ; => "Hello Fanny"

; You can have multi-variadic functions, too
(defn hello3
  ([] "Hello World")
  ([name] (str "Hello " name)))
(hello3 "Jake") ; => "Hello Jake"
(hello3) ; => "Hello World"

; Functions can pack extra arguments up in a seq for you
(defn count-args [& args]
  (str "You passed " (count args) " args: " args))
(count-args 1 2 3) ; => "You passed 3 args: (1 2 3)"

; You can mix regular and packed arguments
(defn hello-count [name & args]
  (str "Hello " name ", you passed " (count args) " extra args"))
(hello-count "Finn" 1 2 3)
; => "Hello Finn, you passed 3 extra args"


; Maps
;;;;;;;;;;

; Hash maps and array maps share an interface. Hash maps have faster lookups
; but don't retain key order.
(class {:a 1 :b 2 :c 3}) ; => clojure.lang.PersistentArrayMap
(class (hash-map :a 1 :b 2 :c 3)) ; => clojure.lang.PersistentHashMap

; Arraymaps will automatically become hashmaps through most operations
; if they get big enough, so you don't need to worry.

; Maps can use any hashable type as a key, but usually keywords are best
; Keywords are like strings with some efficiency bonuses
(class :a) ; => clojure.lang.Keyword

(def stringmap {"a" 1, "b" 2, "c" 3})
stringmap  ; => {"a" 1, "b" 2, "c" 3}

(def keymap {:a 1, :b 2, :c 3})
keymap ; => {:a 1, :c 3, :b 2}

; By the way, commas are always treated as whitespace and do nothing.

; Retrieve a value from a map by calling it as a function
(stringmap "a") ; => 1
(keymap :a) ; => 1

; Keywords can be used to retrieve their value from a map, too!
(:b keymap) ; => 2

; Don't try this with strings.
;("a" stringmap)
; => Exception: java.lang.String cannot be cast to clojure.lang.IFn

; Retrieving a non-present key returns nil
(stringmap "d") ; => nil

; Use assoc to add new keys to hash-maps
(def newkeymap (assoc keymap :d 4))
newkeymap ; => {:a 1, :b 2, :c 3, :d 4}

; But remember, clojure types are immutable!
keymap ; => {:a 1, :b 2, :c 3}

; Use dissoc to remove keys
(dissoc keymap :a :b) ; => {:c 3}

; Sets
;;;;;;

(class #{1 2 3}) ; => clojure.lang.PersistentHashSet
(set [1 2 3 1 2 3 3 2 1 3 2 1]) ; => #{1 2 3}

; Add a member with conj
(conj #{1 2 3} 4) ; => #{1 2 3 4}

; Remove one with disj
(disj #{1 2 3} 1) ; => #{2 3}

; Test for existence by using the set as a function:
(#{1 2 3} 1) ; => 1
(#{1 2 3} 4) ; => nil

; There are more functions in the clojure.sets namespace.

; Useful forms
;;;;;;;;;;;;;;;;;

; Logic constructs in clojure are just macros, and look like
; everything else
(if false "a" "b") ; => "b"
(if false "a") ; => nil

; Use let to create temporary bindings
(let [a 1 b 2]
  (> a b)) ; => false

; Group statements together with do
(do
  (print "Hello")
  "World") ; => "World" (prints "Hello")

; Functions have an implicit do
(defn print-and-say-hello [name]
  (print "Saying hello to " name)
  (str "Hello " name))
(print-and-say-hello "Jeff") ;=> "Hello Jeff" (prints "Saying hello to Jeff")

; So does let
(let [name "Urkel"]
  (print "Saying hello to " name)
  (str "Hello " name)) ; => "Hello Urkel" (prints "Saying hello to Urkel")


; Use the threading macros (-> and ->>) to express transformations of
; data more clearly.

; The "Thread-first" macro (->) inserts into each form the result of
; the previous, as the first argument (second item)
(->
   {:a 1 :b 2}
   (assoc :c 3) ;=> (assoc {:a 1 :b 2} :c 3)
   (dissoc :b)) ;=> (dissoc (assoc {:a 1 :b 2} :c 3) :b)

; This expression could be written as:
; (dissoc (assoc {:a 1 :b 2} :c 3) :b)
; and evaluates to {:a 1 :c 3}

; The double arrow does the same thing, but inserts the result of
; each line at the *end* of the form. This is useful for collection
; operations in particular:
(->>
   (range 10)
   (map inc)     ;=> (map inc (range 10)
   (filter odd?) ;=> (filter odd? (map inc (range 10))
   (into []))    ;=> (into [] (filter odd? (map inc (range 10)))
                 ; Result: [1 3 5 7 9]

; When you are in a situation where you want more freedom as where to
; put the result of previous data transformations in an
; expression, you can use the as-> macro. With it, you can assign a
; specific name to transformations' output and use it as a
; placeholder in your chained expressions:

(as-> [1 2 3] input
  (map inc input);=> You can use last transform's output at the last position
  (nth input 2) ;=>  and at the second position, in the same expression
  (conj [4 5 6] input [8 9 10])) ;=> or in the middle !



; Modules
;;;;;;;;;;;;;;;

; Use "use" to get all functions from the module
(use 'clojure.set)

; Now we can use set operations
(intersection #{1 2 3} #{2 3 4}) ; => #{2 3}
(difference #{1 2 3} #{2 3 4}) ; => #{1}

; You can choose a subset of functions to import, too
(use '[clojure.set :only [intersection]])

; Use require to import a module
(require 'clojure.string)

; Use / to call functions from a module
; Here, the module is clojure.string and the function is blank?
(clojure.string/blank? "") ; => true

; You can give a module a shorter name on import
(require '[clojure.string :as str])
(str/replace "This is a test." #"[a-o]" str/upper-case) ; => "THIs Is A tEst."
; (#"" denotes a regular expression literal)

; You can use require (and use, but don't) from a namespace using :require.
; You don't need to quote your modules if you do it this way.
(ns test
  (:require
    [clojure.string :as str]
    [clojure.set :as set]))

; Java
;;;;;;;;;;;;;;;;;

; Java has a huge and useful standard library, so
; you'll want to learn how to get at it.

; Use import to load a java module
(import java.util.Date)

; You can import from an ns too.
(ns test
  (:import java.util.Date
           java.util.Calendar))

; Use the class name with a "." at the end to make a new instance
(Date.) ; <a date object>

; Use . to call methods. Or, use the ".method" shortcut
(. (Date.) getTime) ; <a timestamp>
(.getTime (Date.)) ; exactly the same thing.

; Use / to call static methods
(System/currentTimeMillis) ; <a timestamp> (system is always present)

; Use doto to make dealing with (mutable) classes more tolerable
(import java.util.Calendar)
(doto (Calendar/getInstance)
  (.set 2000 1 1 0 0 0)
  .getTime) ; => A Date. set to 2000-01-01 00:00:00

; STM
;;;;;;;;;;;;;;;;;

; Software Transactional Memory is the mechanism clojure uses to handle
; persistent state. There are a few constructs in clojure that use this.

; An atom is the simplest. Pass it an initial value
(def my-atom (atom {}))

; Update an atom with swap!.
; swap! takes a function and calls it with the current value of the atom
; as the first argument, and any trailing arguments as the second
(swap! my-atom assoc :a 1) ; Sets my-atom to the result of (assoc {} :a 1)
(swap! my-atom assoc :b 2) ; Sets my-atom to the result of (assoc {:a 1} :b 2)

; Use '@' to dereference the atom and get the value
my-atom  ;=> Atom<#...> (Returns the Atom object)
@my-atom ; => {:a 1 :b 2}

; Here's a simple counter using an atom
(def counter (atom 0))
(defn inc-counter []
  (swap! counter inc))

(inc-counter)
(inc-counter)
(inc-counter)
(inc-counter)
(inc-counter)

@counter ; => 5

; Other STM constructs are refs and agents.
; Refs: http://clojure.org/refs
; Agents: http://clojure.org/agents
----------------------------------------------------
[
	["comment", "; This code is copied from https://learnxinyminutes.com/docs/clojure/"],

	["comment", "; Comments start with semicolons."],

	["comment", "; Clojure is written in \"forms\", which are just"],
	["comment", "; lists of things inside parentheses, separated by whitespace."],
	["comment", ";"],
	["comment", "; The clojure reader assumes that the first thing is a"],
	["comment", "; function or macro to call, and the rest are arguments."],

	["comment", "; The first call in a file should be ns, to set the namespace"],

	["punctuation", "("],
	["keyword", "ns"],
	" learnclojure",
	["punctuation", ")"],

	["comment", "; More basic examples:"],

	["comment", "; str will create a string out of all its arguments"],

	["punctuation", "("],
	["keyword", "str"],
	["string", "\"Hello\""],
	["string", "\" \""],
	["string", "\"World\""],
	["punctuation", ")"],
	["comment", "; => \"Hello World\""],

	["comment", "; Math is straightforward"],

	["punctuation", "("],
	["keyword", "+"],
	["number", "1"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; => 2"],

	["punctuation", "("],
	["keyword", "-"],
	["number", "2"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; => 1"],

	["punctuation", "("],
	["keyword", "*"],
	["number", "1"],
	["number", "2"],
	["punctuation", ")"],
	["comment", "; => 2"],

	["punctuation", "("],
	["keyword", "/"],
	["number", "2"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; => 2"],

	["comment", "; Equality is ="],

	["punctuation", "("],
	["keyword", "="],
	["number", "1"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; => true"],

	["punctuation", "("],
	["keyword", "="],
	["number", "2"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; => false"],

	["comment", "; You need not for logic, too"],

	["punctuation", "("],
	["keyword", "not"],
	["boolean", "true"],
	["punctuation", ")"],
	["comment", "; => false"],

	["comment", "; Nesting forms works as you expect"],

	["punctuation", "("],
	["keyword", "+"],
	["number", "1"],
	["punctuation", "("],
	["keyword", "-"],
	["number", "3"],
	["number", "2"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; = 1 + (3 - 2) => 2"],

	["comment", "; Types"],
	["comment", ";;;;;;;;;;;;;"],

	["comment", "; Clojure uses Java's object types for booleans, strings and numbers."],

	["comment", "; Use `class` to inspect them."],

	["punctuation", "("],
	["keyword", "class"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; Integer literals are java.lang.Long by default"],

	["punctuation", "("],
	["keyword", "class"],
	["number", "1"],
	".",
	["punctuation", ")"],
	["comment", "; Float literals are java.lang.Double"],

	["punctuation", "("],
	["keyword", "class"],
	["string", "\"\""],
	["punctuation", ")"],
	["comment", "; Strings always double-quoted, and are java.lang.String"],

	["punctuation", "("],
	["keyword", "class"],
	["boolean", "false"],
	["punctuation", ")"],
	["comment", "; Booleans are java.lang.Boolean"],

	["punctuation", "("],
	["keyword", "class"],
	["boolean", "nil"],
	["punctuation", ")"],
	["comment", "; The \"null\" value is called nil"],

	["comment", "; If you want to create a literal list of data, use ' to stop it from"],

	["comment", "; being evaluated"],

	"\n'",
	["punctuation", "("],
	["keyword", "+"],
	["number", "1"],
	["number", "2"],
	["punctuation", ")"],
	["comment", "; => (+ 1 2)"],

	["comment", "; (shorthand for (quote (+ 1 2)))"],

	["comment", "; You can eval a quoted list"],

	["punctuation", "("],
	["keyword", "eval"],
	" '",
	["punctuation", "("],
	["keyword", "+"],
	["number", "1"],
	["number", "2"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => 3"],

	["comment", "; Collections & Sequences"],
	["comment", ";;;;;;;;;;;;;;;;;;;"],

	["comment", "; Lists are linked-list data structures, while Vectors are array-backed."],

	["comment", "; Vectors and Lists are java classes too!"],

	["punctuation", "("],
	["keyword", "class"],
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "]"],
	["punctuation", ")"],
	["comment", "; => clojure.lang.PersistentVector"],

	["punctuation", "("],
	["keyword", "class"],
	" '",
	["punctuation", "("],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => clojure.lang.PersistentList"],

	["comment", "; A list would be written as just (1 2 3), but we have to quote"],
	["comment", "; it to stop the reader thinking it's a function."],
	["comment", "; Also, (list 1 2 3) is the same as '(1 2 3)"],

	["comment", "; \"Collections\" are just groups of data"],

	["comment", "; Both lists and vectors are collections:"],

	["punctuation", "("],
	["function", "coll?"],
	" '",
	["punctuation", "("],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => true"],

	["punctuation", "("],
	["function", "coll?"],
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "]"],
	["punctuation", ")"],
	["comment", "; => true"],

	["comment", "; \"Sequences\" (seqs) are abstract descriptions of lists of data."],

	["comment", "; Only lists are seqs."],

	["punctuation", "("],
	["keyword", "seq?"],
	" '",
	["punctuation", "("],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => true"],

	["punctuation", "("],
	["keyword", "seq?"],
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "]"],
	["punctuation", ")"],
	["comment", "; => false"],

	["comment", "; A seq need only provide an entry when it is accessed."],

	["comment", "; So, seqs which can be lazy -- they can define infinite series:"],

	["punctuation", "("],
	["keyword", "range"],
	["number", "4"],
	["punctuation", ")"],
	["comment", "; => (0 1 2 3)"],

	["punctuation", "("],
	["keyword", "range"],
	["punctuation", ")"],
	["comment", "; => (0 1 2 3 4 ...) (an infinite series)"],

	["punctuation", "("],
	["keyword", "take"],
	["number", "4"],
	["punctuation", "("],
	["keyword", "range"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", ";  (0 1 2 3)"],

	["comment", "; Use cons to add an item to the beginning of a list or vector"],

	["punctuation", "("],
	["keyword", "cons"],
	["number", "4"],
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "]"],
	["punctuation", ")"],
	["comment", "; => (4 1 2 3)"],

	["punctuation", "("],
	["keyword", "cons"],
	["number", "4"],
	" '",
	["punctuation", "("],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => (4 1 2 3)"],

	["comment", "; Conj will add an item to a collection in the most efficient way."],

	["comment", "; For lists, they insert at the beginning. For vectors, they insert at the end."],

	["punctuation", "("],
	["keyword", "conj"],
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "]"],
	["number", "4"],
	["punctuation", ")"],
	["comment", "; => [1 2 3 4]"],

	["punctuation", "("],
	["keyword", "conj"],
	" '",
	["punctuation", "("],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", ")"],
	["number", "4"],
	["punctuation", ")"],
	["comment", "; => (4 1 2 3)"],

	["comment", "; Use concat to add lists or vectors together"],

	["punctuation", "("],
	["keyword", "concat"],
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["punctuation", "]"],
	" '",
	["punctuation", "("],
	["number", "3"],
	["number", "4"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => (1 2 3 4)"],

	["comment", "; Use filter, map to interact with collections"],

	["punctuation", "("],
	["keyword", "map"],
	" inc ",
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "]"],
	["punctuation", ")"],
	["comment", "; => (2 3 4)"],

	["punctuation", "("],
	["keyword", "filter"],
	" even? ",
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "]"],
	["punctuation", ")"],
	["comment", "; => (2)"],

	["comment", "; Use reduce to reduce them"],

	["punctuation", "("],
	["keyword", "reduce"],
	" + ",
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["number", "4"],
	["punctuation", "]"],
	["punctuation", ")"],

	["comment", "; = (+ (+ (+ 1 2) 3) 4)"],

	["comment", "; => 10"],

	["comment", "; Reduce can take an initial-value argument too"],

	["punctuation", "("],
	["keyword", "reduce"],
	" conj ",
	["punctuation", "["],
	["punctuation", "]"],
	" '",
	["punctuation", "("],
	["number", "3"],
	["number", "2"],
	["number", "1"],
	["punctuation", ")"],
	["punctuation", ")"],

	["comment", "; = (conj (conj (conj [] 3) 2) 1)"],

	["comment", "; => [3 2 1]"],

	["comment", "; Functions"],
	["comment", ";;;;;;;;;;;;;;;;;;;;;"],

	["comment", "; Use fn to create new functions. A function always returns"],

	["comment", "; its last statement."],

	["punctuation", "("],
	["keyword", "fn"],
	["punctuation", "["],
	["punctuation", "]"],
	["string", "\"Hello World\""],
	["punctuation", ")"],
	["comment", "; => fn"],

	["comment", "; (You need extra parens to call it)"],

	["punctuation", "("],
	["punctuation", "("],
	["keyword", "fn"],
	["punctuation", "["],
	["punctuation", "]"],
	["string", "\"Hello World\""],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => \"Hello World\""],

	["comment", "; You can create a var using def"],

	["punctuation", "("],
	["keyword", "def"],
	" x ",
	["number", "1"],
	["punctuation", ")"],

	"\nx ",
	["comment", "; => 1"],

	["comment", "; Assign a function to a var"],

	["punctuation", "("],
	["keyword", "def"],
	" hello-world ",
	["punctuation", "("],
	["keyword", "fn"],
	["punctuation", "["],
	["punctuation", "]"],
	["string", "\"Hello World\""],
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", "hello-world"],
	["punctuation", ")"],
	["comment", "; => \"Hello World\""],

	["comment", "; You can shorten this process by using defn"],

	["punctuation", "("],
	["keyword", "defn"],
	" hello-world ",
	["punctuation", "["],
	["punctuation", "]"],
	["string", "\"Hello World\""],
	["punctuation", ")"],

	["comment", "; The [] is the list of arguments for the function."],

	["punctuation", "("],
	["keyword", "defn"],
	" hello ",
	["punctuation", "["],
	"name",
	["punctuation", "]"],

	["punctuation", "("],
	["keyword", "str"],
	["string", "\"Hello \""],
	" name",
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", "hello"],
	["string", "\"Steve\""],
	["punctuation", ")"],
	["comment", "; => \"Hello Steve\""],

	["comment", "; You can also use this shorthand to create functions:"],

	["punctuation", "("],
	["keyword", "def"],
	" hello2 ",
	["operator", "#"],
	["punctuation", "("],
	["keyword", "str"],
	["string", "\"Hello \""],
	" %",
	["number", "1"],
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", "hello2"],
	["string", "\"Fanny\""],
	["punctuation", ")"],
	["comment", "; => \"Hello Fanny\""],

	["comment", "; You can have multi-variadic functions, too"],

	["punctuation", "("],
	["keyword", "defn"],
	" hello3\n  ",

	["punctuation", "("],
	["punctuation", "["],
	["punctuation", "]"],
	["string", "\"Hello World\""],
	["punctuation", ")"],

	["punctuation", "("],
	["punctuation", "["],
	"name",
	["punctuation", "]"],
	["punctuation", "("],
	["keyword", "str"],
	["string", "\"Hello \""],
	" name",
	["punctuation", ")"],
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", "hello3"],
	["string", "\"Jake\""],
	["punctuation", ")"],
	["comment", "; => \"Hello Jake\""],

	["punctuation", "("],
	["function", "hello3"],
	["punctuation", ")"],
	["comment", "; => \"Hello World\""],

	["comment", "; Functions can pack extra arguments up in a seq for you"],

	["punctuation", "("],
	["keyword", "defn"],
	" count-args ",
	["punctuation", "["],
	"& args",
	["punctuation", "]"],

	["punctuation", "("],
	["keyword", "str"],
	["string", "\"You passed \""],
	["punctuation", "("],
	["keyword", "count"],
	" args",
	["punctuation", ")"],
	["string", "\" args: \""],
	" args",
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", "count-args"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", ")"],
	["comment", "; => \"You passed 3 args: (1 2 3)\""],

	["comment", "; You can mix regular and packed arguments"],

	["punctuation", "("],
	["keyword", "defn"],
	" hello-count ",
	["punctuation", "["],
	"name & args",
	["punctuation", "]"],

	["punctuation", "("],
	["keyword", "str"],
	["string", "\"Hello \""],
	" name ",
	["string", "\", you passed \""],
	["punctuation", "("],
	["keyword", "count"],
	" args",
	["punctuation", ")"],
	["string", "\" extra args\""],
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", "hello-count"],
	["string", "\"Finn\""],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", ")"],

	["comment", "; => \"Hello Finn, you passed 3 extra args\""],

	["comment", "; Maps"],
	["comment", ";;;;;;;;;;"],

	["comment", "; Hash maps and array maps share an interface. Hash maps have faster lookups"],

	["comment", "; but don't retain key order."],

	["punctuation", "("],
	["keyword", "class"],
	["punctuation", "{"],
	["symbol", ":a"],
	["number", "1"],
	["symbol", ":b"],
	["number", "2"],
	["symbol", ":c"],
	["number", "3"],
	["punctuation", "}"],
	["punctuation", ")"],
	["comment", "; => clojure.lang.PersistentArrayMap"],

	["punctuation", "("],
	["keyword", "class"],
	["punctuation", "("],
	["keyword", "hash-map"],
	["symbol", ":a"],
	["number", "1"],
	["symbol", ":b"],
	["number", "2"],
	["symbol", ":c"],
	["number", "3"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => clojure.lang.PersistentHashMap"],

	["comment", "; Arraymaps will automatically become hashmaps through most operations"],
	["comment", "; if they get big enough, so you don't need to worry."],

	["comment", "; Maps can use any hashable type as a key, but usually keywords are best"],

	["comment", "; Keywords are like strings with some efficiency bonuses"],

	["punctuation", "("],
	["keyword", "class"],
	["symbol", ":a"],
	["punctuation", ")"],
	["comment", "; => clojure.lang.Keyword"],

	["punctuation", "("],
	["keyword", "def"],
	" stringmap ",
	["punctuation", "{"],
	["string", "\"a\""],
	["number", "1"],
	["punctuation", ","],
	["string", "\"b\""],
	["number", "2"],
	["punctuation", ","],
	["string", "\"c\""],
	["number", "3"],
	["punctuation", "}"],
	["punctuation", ")"],

	"\nstringmap  ",
	["comment", "; => {\"a\" 1, \"b\" 2, \"c\" 3}"],

	["punctuation", "("],
	["keyword", "def"],
	" keymap ",
	["punctuation", "{"],
	["symbol", ":a"],
	["number", "1"],
	["punctuation", ","],
	["symbol", ":b"],
	["number", "2"],
	["punctuation", ","],
	["symbol", ":c"],
	["number", "3"],
	["punctuation", "}"],
	["punctuation", ")"],

	"\nkeymap ",
	["comment", "; => {:a 1, :c 3, :b 2}"],

	["comment", "; By the way, commas are always treated as whitespace and do nothing."],

	["comment", "; Retrieve a value from a map by calling it as a function"],

	["punctuation", "("],
	["function", "stringmap"],
	["string", "\"a\""],
	["punctuation", ")"],
	["comment", "; => 1"],

	["punctuation", "("],
	["function", "keymap"],
	["symbol", ":a"],
	["punctuation", ")"],
	["comment", "; => 1"],

	["comment", "; Keywords can be used to retrieve their value from a map, too!"],

	["punctuation", "("],
	["symbol", ":b"],
	" keymap",
	["punctuation", ")"],
	["comment", "; => 2"],

	["comment", "; Don't try this with strings."],
	["comment", ";(\"a\" stringmap)"],
	["comment", "; => Exception: java.lang.String cannot be cast to clojure.lang.IFn"],

	["comment", "; Retrieving a non-present key returns nil"],

	["punctuation", "("],
	["function", "stringmap"],
	["string", "\"d\""],
	["punctuation", ")"],
	["comment", "; => nil"],

	["comment", "; Use assoc to add new keys to hash-maps"],

	["punctuation", "("],
	["keyword", "def"],
	" newkeymap ",
	["punctuation", "("],
	["keyword", "assoc"],
	" keymap ",
	["symbol", ":d"],
	["number", "4"],
	["punctuation", ")"],
	["punctuation", ")"],

	"\nnewkeymap ",
	["comment", "; => {:a 1, :b 2, :c 3, :d 4}"],

	["comment", "; But remember, clojure types are immutable!"],
	"\nkeymap ", ["comment", "; => {:a 1, :b 2, :c 3}"],

	["comment", "; Use dissoc to remove keys"],

	["punctuation", "("],
	["keyword", "dissoc"],
	" keymap ",
	["symbol", ":a"],
	["symbol", ":b"],
	["punctuation", ")"],
	["comment", "; => {:c 3}"],

	["comment", "; Sets"],
	["comment", ";;;;;;"],

	["punctuation", "("],
	["keyword", "class"],
	["operator", "#"],
	["punctuation", "{"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "}"],
	["punctuation", ")"],
	["comment", "; => clojure.lang.PersistentHashSet"],

	["punctuation", "("],
	["keyword", "set"],
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["number", "3"],
	["number", "2"],
	["number", "1"],
	["number", "3"],
	["number", "2"],
	["number", "1"],
	["punctuation", "]"],
	["punctuation", ")"],
	["comment", "; => #{1 2 3}"],

	["comment", "; Add a member with conj"],

	["punctuation", "("],
	["keyword", "conj"],
	["operator", "#"],
	["punctuation", "{"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "}"],
	["number", "4"],
	["punctuation", ")"],
	["comment", "; => #{1 2 3 4}"],

	["comment", "; Remove one with disj"],

	["punctuation", "("],
	["keyword", "disj"],
	["operator", "#"],
	["punctuation", "{"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "}"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; => #{2 3}"],

	["comment", "; Test for existence by using the set as a function:"],

	["punctuation", "("],
	["operator", "#"],
	["punctuation", "{"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "}"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; => 1"],

	["punctuation", "("],
	["operator", "#"],
	["punctuation", "{"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "}"],
	["number", "4"],
	["punctuation", ")"],
	["comment", "; => nil"],

	["comment", "; There are more functions in the clojure.sets namespace."],

	["comment", "; Useful forms"],
	["comment", ";;;;;;;;;;;;;;;;;"],

	["comment", "; Logic constructs in clojure are just macros, and look like"],

	["comment", "; everything else"],

	["punctuation", "("],
	["keyword", "if"],
	["boolean", "false"],
	["string", "\"a\""],
	["string", "\"b\""],
	["punctuation", ")"],
	["comment", "; => \"b\""],

	["punctuation", "("],
	["keyword", "if"],
	["boolean", "false"],
	["string", "\"a\""],
	["punctuation", ")"],
	["comment", "; => nil"],

	["comment", "; Use let to create temporary bindings"],

	["punctuation", "("],
	["keyword", "let"],
	["punctuation", "["],
	"a ",
	["number", "1"],
	" b ",
	["number", "2"],
	["punctuation", "]"],

	["punctuation", "("],
	["keyword", ">"],
	" a b",
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => false"],

	["comment", "; Group statements together with do"],

	["punctuation", "("],
	["keyword", "do"],

	["punctuation", "("],
	["keyword", "print"],
	["string", "\"Hello\""],
	["punctuation", ")"],

	["string", "\"World\""],
	["punctuation", ")"],
	["comment", "; => \"World\" (prints \"Hello\")"],

	["comment", "; Functions have an implicit do"],

	["punctuation", "("],
	["keyword", "defn"],
	" print-and-say-hello ",
	["punctuation", "["],
	"name",
	["punctuation", "]"],

	["punctuation", "("],
	["keyword", "print"],
	["string", "\"Saying hello to \""],
	" name",
	["punctuation", ")"],

	["punctuation", "("],
	["keyword", "str"],
	["string", "\"Hello \""],
	" name",
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", "print-and-say-hello"],
	["string", "\"Jeff\""],
	["punctuation", ")"],
	["comment", ";=> \"Hello Jeff\" (prints \"Saying hello to Jeff\")"],

	["comment", "; So does let"],

	["punctuation", "("],
	["keyword", "let"],
	["punctuation", "["],
	"name ",
	["string", "\"Urkel\""],
	["punctuation", "]"],

	["punctuation", "("],
	["keyword", "print"],
	["string", "\"Saying hello to \""],
	" name",
	["punctuation", ")"],

	["punctuation", "("],
	["keyword", "str"],
	["string", "\"Hello \""],
	" name",
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; => \"Hello Urkel\" (prints \"Saying hello to Urkel\")"],

	["comment", "; Use the threading macros (-> and ->>) to express transformations of"],
	["comment", "; data more clearly."],

	["comment", "; The \"Thread-first\" macro (->) inserts into each form the result of"],

	["comment", "; the previous, as the first argument (second item)"],

	["punctuation", "("],
	["keyword", "->"],

	["punctuation", "{"],
	["symbol", ":a"],
	["number", "1"],
	["symbol", ":b"],
	["number", "2"],
	["punctuation", "}"],

	["punctuation", "("],
	["keyword", "assoc"],
	["symbol", ":c"],
	["number", "3"],
	["punctuation", ")"],
	["comment", ";=> (assoc {:a 1 :b 2} :c 3)"],

	["punctuation", "("],
	["keyword", "dissoc"],
	["symbol", ":b"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", ";=> (dissoc (assoc {:a 1 :b 2} :c 3) :b)"],

	["comment", "; This expression could be written as:"],
	["comment", "; (dissoc (assoc {:a 1 :b 2} :c 3) :b)"],
	["comment", "; and evaluates to {:a 1 :c 3}"],

	["comment", "; The double arrow does the same thing, but inserts the result of"],

	["comment", "; each line at the *end* of the form. This is useful for collection"],

	["comment", "; operations in particular:"],

	["punctuation", "("],
	["keyword", "->>"],

	["punctuation", "("],
	["keyword", "range"],
	["number", "10"],
	["punctuation", ")"],

	["punctuation", "("],
	["keyword", "map"],
	" inc",
	["punctuation", ")"],
	["comment", ";=> (map inc (range 10)"],

	["punctuation", "("],
	["keyword", "filter"],
	" odd?",
	["punctuation", ")"],
	["comment", ";=> (filter odd? (map inc (range 10))"],

	["punctuation", "("],
	["keyword", "into"],
	["punctuation", "["],
	["punctuation", "]"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", ";=> (into [] (filter odd? (map inc (range 10)))"],

	["comment", "; Result: [1 3 5 7 9]"],

	["comment", "; When you are in a situation where you want more freedom as where to"],
	["comment", "; put the result of previous data transformations in an"],
	["comment", "; expression, you can use the as-> macro. With it, you can assign a"],
	["comment", "; specific name to transformations' output and use it as a"],
	["comment", "; placeholder in your chained expressions:"],

	["punctuation", "("],
	["function", "as->"],
	["punctuation", "["],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "]"],
	" input\n  ",

	["punctuation", "("],
	["keyword", "map"],
	" inc input",
	["punctuation", ")"],
	["comment", ";=> You can use last transform's output at the last position"],

	["punctuation", "("],
	["keyword", "nth"],
	" input ",
	["number", "2"],
	["punctuation", ")"],
	["comment", ";=>  and at the second position, in the same expression"],

	["punctuation", "("],
	["keyword", "conj"],
	["punctuation", "["],
	["number", "4"],
	["number", "5"],
	["number", "6"],
	["punctuation", "]"],
	" input ",
	["punctuation", "["],
	["number", "8"],
	["number", "9"],
	["number", "10"],
	["punctuation", "]"],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", ";=> or in the middle !"],

	["comment", "; Modules"],
	["comment", ";;;;;;;;;;;;;;;"],

	["comment", "; Use \"use\" to get all functions from the module"],

	["punctuation", "("],
	["function", "use"],
	" 'clojure.set",
	["punctuation", ")"],

	["comment", "; Now we can use set operations"],

	["punctuation", "("],
	["keyword", "intersection"],
	["operator", "#"],
	["punctuation", "{"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "}"],
	["operator", "#"],
	["punctuation", "{"],
	["number", "2"],
	["number", "3"],
	["number", "4"],
	["punctuation", "}"],
	["punctuation", ")"],
	["comment", "; => #{2 3}"],

	["punctuation", "("],
	["keyword", "difference"],
	["operator", "#"],
	["punctuation", "{"],
	["number", "1"],
	["number", "2"],
	["number", "3"],
	["punctuation", "}"],
	["operator", "#"],
	["punctuation", "{"],
	["number", "2"],
	["number", "3"],
	["number", "4"],
	["punctuation", "}"],
	["punctuation", ")"],
	["comment", "; => #{1}"],

	["comment", "; You can choose a subset of functions to import, too"],

	["punctuation", "("],
	["function", "use"],
	" '",
	["punctuation", "["],
	"clojure.set ",
	["symbol", ":only"],
	["punctuation", "["],
	"intersection",
	["punctuation", "]"],
	["punctuation", "]"],
	["punctuation", ")"],

	["comment", "; Use require to import a module"],

	["punctuation", "("],
	["function", "require"],
	" 'clojure.string",
	["punctuation", ")"],

	["comment", "; Use / to call functions from a module"],

	["comment", "; Here, the module is clojure.string and the function is blank?"],

	["punctuation", "("],
	["function", "clojure.string/blank?"],
	["string", "\"\""],
	["punctuation", ")"],
	["comment", "; => true"],

	["comment", "; You can give a module a shorter name on import"],

	["punctuation", "("],
	["function", "require"],
	" '",
	["punctuation", "["],
	"clojure.string ",
	["symbol", ":as"],
	" str",
	["punctuation", "]"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", "str/replace"],
	["string", "\"This is a test.\""],
	["operator", "#"],
	["string", "\"[a-o]\""],
	" str/upper-case",
	["punctuation", ")"],
	["comment", "; => \"THIs Is A tEst.\""],

	["comment", "; (#\"\" denotes a regular expression literal)"],

	["comment", "; You can use require (and use, but don't) from a namespace using :require."],

	["comment", "; You don't need to quote your modules if you do it this way."],

	["punctuation", "("],
	["keyword", "ns"],
	" test\n  ",

	["punctuation", "("],
	["symbol", ":require"],

	["punctuation", "["],
	"clojure.string ",
	["symbol", ":as"],
	" str",
	["punctuation", "]"],

	["punctuation", "["],
	"clojure.set ",
	["symbol", ":as"],
	" set",
	["punctuation", "]"],
	["punctuation", ")"],
	["punctuation", ")"],

	["comment", "; Java"],
	["comment", ";;;;;;;;;;;;;;;;;"],

	["comment", "; Java has a huge and useful standard library, so"],
	["comment", "; you'll want to learn how to get at it."],

	["comment", "; Use import to load a java module"],

	["punctuation", "("],
	["keyword", "import"],
	" java.util.Date",
	["punctuation", ")"],

	["comment", "; You can import from an ns too."],

	["punctuation", "("],
	["keyword", "ns"],
	" test\n  ",

	["punctuation", "("],
	["symbol", ":import"],
	" java.util.Date\n           java.util.Calendar",
	["punctuation", ")"],
	["punctuation", ")"],

	["comment", "; Use the class name with a \".\" at the end to make a new instance"],

	["punctuation", "("],
	["function", "Date."],
	["punctuation", ")"],
	["comment", "; <a date object>"],

	["comment", "; Use . to call methods. Or, use the \".method\" shortcut"],

	["punctuation", "("],
	["keyword", "."],
	["punctuation", "("],
	["function", "Date."],
	["punctuation", ")"],
	" getTime",
	["punctuation", ")"],
	["comment", "; <a timestamp>"],

	["punctuation", "("],
	["function", ".getTime"],
	["punctuation", "("],
	["function", "Date."],
	["punctuation", ")"],
	["punctuation", ")"],
	["comment", "; exactly the same thing."],

	["comment", "; Use / to call static methods"],

	["punctuation", "("],
	["function", "System/currentTimeMillis"],
	["punctuation", ")"],
	["comment", "; <a timestamp> (system is always present)"],

	["comment", "; Use doto to make dealing with (mutable) classes more tolerable"],

	["punctuation", "("],
	["keyword", "import"],
	" java.util.Calendar",
	["punctuation", ")"],

	["punctuation", "("],
	["keyword", "doto"],
	["punctuation", "("],
	["function", "Calendar/getInstance"],
	["punctuation", ")"],

	["punctuation", "("],
	["function", ".set"],
	["number", "2000"],
	["number", "1"],
	["number", "1"],
	["number", "0"],
	["number", "0"],
	["number", "0"],
	["punctuation", ")"],

	"\n  .getTime",
	["punctuation", ")"],
	["comment", "; => A Date. set to 2000-01-01 00:00:00"],

	["comment", "; STM"],
	["comment", ";;;;;;;;;;;;;;;;;"],

	["comment", "; Software Transactional Memory is the mechanism clojure uses to handle"],
	["comment", "; persistent state. There are a few constructs in clojure that use this."],

	["comment", "; An atom is the simplest. Pass it an initial value"],

	["punctuation", "("],
	["keyword", "def"],
	" my-atom ",
	["punctuation", "("],
	["function", "atom"],
	["punctuation", "{"],
	["punctuation", "}"],
	["punctuation", ")"],
	["punctuation", ")"],

	["comment", "; Update an atom with swap!."],

	["comment", "; swap! takes a function and calls it with the current value of the atom"],

	["comment", "; as the first argument, and any trailing arguments as the second"],

	["punctuation", "("],
	["function", "swap!"],
	" my-atom assoc ",
	["symbol", ":a"],
	["number", "1"],
	["punctuation", ")"],
	["comment", "; Sets my-atom to the result of (assoc {} :a 1)"],

	["punctuation", "("],
	["function", "swap!"],
	" my-atom assoc ",
	["symbol", ":b"],
	["number", "2"],
	["punctuation", ")"],
	["comment", "; Sets my-atom to the result of (assoc {:a 1} :b 2)"],

	["comment", "; Use '@' to dereference the atom and get the value"],
	"\nmy-atom  ", ["comment", ";=> Atom<#...> (Returns the Atom object)"],
	["operator", "@"], "my-atom ", ["comment", "; => {:a 1 :b 2}"],

	["comment", "; Here's a simple counter using an atom"],

	["punctuation", "("],
	["keyword", "def"],
	" counter ",
	["punctuation", "("],
	["function", "atom"],
	["number", "0"],
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("],
	["keyword", "defn"],
	" inc-counter ",
	["punctuation", "["],
	["punctuation", "]"],

	["punctuation", "("],
	["function", "swap!"],
	" counter inc",
	["punctuation", ")"],
	["punctuation", ")"],

	["punctuation", "("], ["function", "inc-counter"], ["punctuation", ")"],
	["punctuation", "("], ["function", "inc-counter"], ["punctuation", ")"],
	["punctuation", "("], ["function", "inc-counter"], ["punctuation", ")"],
	["punctuation", "("], ["function", "inc-counter"], ["punctuation", ")"],
	["punctuation", "("], ["function", "inc-counter"], ["punctuation", ")"],

	["operator", "@"], "counter ", ["comment", "; => 5"],

	["comment", "; Other STM constructs are refs and agents."],
	["comment", "; Refs: http://clojure.org/refs"],
	["comment", "; Agents: http://clojure.org/agents"]
]

----------------------------------------------------